<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Struttura Cristallina EC</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000000; font-family: 'Segoe UI', sans-serif; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const atomRadius = 0.15;
        const bondRadius = 0.02;
        const atomColor = 0x9b59b6; // Viola
        const atomColorInner = 0xe74c3c; // Rosso per gli atomi interni
        const bondColor = 0xbdc3c7;

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000); // Sfondo nero
        scene.fog = new THREE.Fog(0x000000, 5, 20); // Nebbia nera

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(5, 4, 6);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 10, 7);
        dirLight.castShadow = true;
        scene.add(dirLight);

        const latticeGroup = new THREE.Group();
        scene.add(latticeGroup);

        function createAtom(x, y, z, isInner = false) {
            const geometry = new THREE.SphereGeometry(atomRadius, 32, 32);
            const material = new THREE.MeshPhysicalMaterial({
                color: isInner ? atomColorInner : atomColor,
                metalness: 0.3, roughness: 0.2, clearcoat: 1.0
            });
            const atom = new THREE.Mesh(geometry, material);
            atom.position.set(x, y, z);
            atom.castShadow = true;
            latticeGroup.add(atom);
        }

        function createBond(start, end) {
            const startVec = new THREE.Vector3(start.x, start.y, start.z);
            const endVec = new THREE.Vector3(end.x, end.y, end.z);
            const direction = new THREE.Vector3().subVectors(endVec, startVec);
            const geometry = new THREE.CylinderGeometry(bondRadius, bondRadius, direction.length(), 8);
            const material = new THREE.MeshStandardMaterial({ color: bondColor });
            const bond = new THREE.Mesh(geometry, material);
            bond.position.copy(startVec).add(direction.multiplyScalar(0.5));
            bond.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction.clone().normalize());
            latticeGroup.add(bond);
        }

        // --- Logica EC ---
        const hexRadius = 1.0;
        const height = 1.633 * hexRadius;

        // Funzione per creare uno strato esagonale
        const createHexLayer = (yPos) => {
            const layerAtoms = [];
            // Centrale
            const center = {x: 0, y: yPos, z: 0};
            createAtom(center.x, center.y, center.z);
            layerAtoms.push(center);

            // 6 Atomi esterni
            for (let i = 0; i < 6; i++) {
                const angle = (i * 60) * (Math.PI / 180);
                const px = hexRadius * Math.cos(angle);
                const pz = hexRadius * Math.sin(angle);
                createAtom(px, yPos, pz);
                layerAtoms.push({x: px, y: yPos, z: pz});
            }
            
            // Legami interni al layer
            for(let i=1; i<=6; i++) {
                createBond(layerAtoms[0], layerAtoms[i]); // Raggi
                const next = (i === 6) ? 1 : i + 1;
                createBond(layerAtoms[i], layerAtoms[next]); // Perimetro
            }
        };

        // Strato A (Basso)
        createHexLayer(-height/2);
        // Strato A (Alto)
        createHexLayer(height/2);

        // Strato B (Intermedio - 3 atomi interni)
        const midY = 0;
        for (let i = 0; i < 3; i++) {
            // Coordinate dei vuoti tetraedrici
            const angleMid = (i * 120 + 90) * (Math.PI / 180); 
            const rInner = hexRadius * 0.577;
            
            const tx = rInner * Math.cos(angleMid);
            const tz = rInner * Math.sin(angleMid);

            createAtom(tx, midY, tz, true);
        }

        // Legami verticali esterni
        for (let i = 0; i < 6; i++) {
            const angle = (i * 60) * (Math.PI / 180);
            const x = hexRadius * Math.cos(angle);
            const z = hexRadius * Math.sin(angle);
            createBond({x:x, y:-height/2, z:z}, {x:x, y:height/2, z:z});
        }
        
        createBond({x:0, y:-height/2, z:0}, {x:0, y:height/2, z:0});

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        animate();
    </script>
</body>
</html>        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const atomRadius = 0.15;
        const bondRadius = 0.02;
        const atomColor = 0x9b59b6; // Viola
        const atomColorInner = 0xe74c3c; // Rosso per gli atomi interni
        const bondColor = 0xbdc3c7;

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);
        scene.fog = new THREE.Fog(0xf0f0f0, 5, 20);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(5, 4, 6);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 10, 7);
        dirLight.castShadow = true;
        scene.add(dirLight);

        const latticeGroup = new THREE.Group();
        scene.add(latticeGroup);

        function createAtom(x, y, z, isInner = false) {
            const geometry = new THREE.SphereGeometry(atomRadius, 32, 32);
            const material = new THREE.MeshPhysicalMaterial({
                color: isInner ? atomColorInner : atomColor,
                metalness: 0.3, roughness: 0.2, clearcoat: 1.0
            });
            const atom = new THREE.Mesh(geometry, material);
            atom.position.set(x, y, z);
            atom.castShadow = true;
            latticeGroup.add(atom);
        }

        function createBond(start, end) {
            const startVec = new THREE.Vector3(start.x, start.y, start.z);
            const endVec = new THREE.Vector3(end.x, end.y, end.z);
            const direction = new THREE.Vector3().subVectors(endVec, startVec);
            const geometry = new THREE.CylinderGeometry(bondRadius, bondRadius, direction.length(), 8);
            const material = new THREE.MeshStandardMaterial({ color: bondColor });
            const bond = new THREE.Mesh(geometry, material);
            bond.position.copy(startVec).add(direction.multiplyScalar(0.5));
            bond.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction.clone().normalize());
            latticeGroup.add(bond);
        }

        // --- Logica EC ---
        const hexRadius = 1.0;
        const height = 1.633 * hexRadius;

        // Funzione per creare uno strato esagonale
        const createHexLayer = (yPos) => {
            const layerAtoms = [];
            // Centrale
            const center = {x: 0, y: yPos, z: 0};
            createAtom(center.x, center.y, center.z);
            layerAtoms.push(center);

            // 6 Atomi esterni
            for (let i = 0; i < 6; i++) {
                const angle = (i * 60) * (Math.PI / 180);
                const px = hexRadius * Math.cos(angle);
                const pz = hexRadius * Math.sin(angle);
                createAtom(px, yPos, pz);
                layerAtoms.push({x: px, y: yPos, z: pz});
            }
            
            // Legami interni al layer
            for(let i=1; i<=6; i++) {
                createBond(layerAtoms[0], layerAtoms[i]); // Raggi
                const next = (i === 6) ? 1 : i + 1;
                createBond(layerAtoms[i], layerAtoms[next]); // Perimetro
            }
        };

        // Strato A (Basso)
        createHexLayer(-height/2);
        // Strato A (Alto)
        createHexLayer(height/2);

        // Strato B (Intermedio - 3 atomi interni)
        const midY = 0;
        for (let i = 0; i < 3; i++) {
            // Coordinate dei vuoti tetraedrici
            const angleMid = (i * 120 + 90) * (Math.PI / 180); 
            // Posizione geometrica ideale: 
            // raggio del centro del triangolo = raggioEsagono / sqrt(3) ~= 0.577 * raggioEsagono
            const rInner = hexRadius * 0.577;
            
            const tx = rInner * Math.cos(angleMid);
            const tz = rInner * Math.sin(angleMid);

            createAtom(tx, midY, tz, true);
        }

        // Legami verticali esterni
        for (let i = 0; i < 6; i++) {
            const angle = (i * 60) * (Math.PI / 180);
            const x = hexRadius * Math.cos(angle);
            const z = hexRadius * Math.sin(angle);
            createBond({x:x, y:-height/2, z:z}, {x:x, y:height/2, z:z});
        }
        
        // Legame verticale centrale (opzionale, spesso omesso per chiarezza, qui lo metto)
        createBond({x:0, y:-height/2, z:0}, {x:0, y:height/2, z:0});

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        animate();
    </script>
</body>
</html>
